name: Build and Deploy React App

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      repo_name: ${{ steps.define_repo_name.outputs.repo_name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install semver
        run: npm install -g semver

      - name: Create initial tag if needed
        id: create_initial_tag
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          if [ -z "$(git tag)" ]; then
            git config --global user.name 'github-actions'
            git config --global user.email 'github-actions@github.com'
            git tag -a v0.0.0 -m "Initial release"
            git push origin v0.0.0
          fi

      - name: Calculate version
        id: version
        run: |
          git fetch --tags
          LAST_TAG=$(git describe --tags `git rev-list --tags --max-count=1`)
          [ -z "$LAST_TAG" ] && LAST_TAG="v0.0.0"
          CURRENT_VERSION=${LAST_TAG#v}

          COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s")
          MAJOR=0; MINOR=0; PATCH=0

          for COMMIT in $COMMITS; do
            [[ "$COMMIT" == *"BREAKING CHANGE"* ]] && MAJOR=1
            [[ "$COMMIT" == *"feat"* ]] && MINOR=1
            [[ "$COMMIT" == *"fix"* ]] && PATCH=1
          done

          NEW_VERSION=$CURRENT_VERSION
          [[ $MAJOR -eq 1 ]] && NEW_VERSION=$(semver -i major $CURRENT_VERSION)
          [[ $MINOR -eq 1 && $MAJOR -eq 0 ]] && NEW_VERSION=$(semver -i minor $CURRENT_VERSION)
          [[ $PATCH -eq 1 && $MINOR -eq 0 && $MAJOR -eq 0 ]] && NEW_VERSION=$(semver -i patch $CURRENT_VERSION)

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "should_deploy=$([[ "$NEW_VERSION" != "$CURRENT_VERSION" ]] && echo true || echo false)" >> $GITHUB_OUTPUT

      - name: Docker login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Define repo name
        id: define_repo_name
        run: |
          REPO="${{ github.repository }}"
          REPO_NAME="${REPO#*/}"
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV

      - name: Build Docker image
        if: steps.version.outputs.should_deploy == 'true'
        run: |
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/$REPO_NAME:${{ steps.version.outputs.new_version }} .
          docker tag ${{ secrets.DOCKERHUB_USERNAME }}/$REPO_NAME:${{ steps.version.outputs.new_version }} ${{ secrets.DOCKERHUB_USERNAME }}/$REPO_NAME:latest

      - name: Push Docker image
        if: steps.version.outputs.should_deploy == 'true'
        run: |
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/$REPO_NAME:${{ steps.version.outputs.new_version }}
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/$REPO_NAME:latest

      - name: Update version in package.json and commit
        if: steps.version.outputs.should_deploy == 'true'
        run: |
          npm version ${{ steps.version.outputs.new_version }} --no-git-tag-version
          git config --global user.name 'github-actions'
          git config --global user.email 'github-actions@github.com'
          git add package.json
          git commit -m "chore: release ${{ steps.version.outputs.new_version }}"
          git tag v${{ steps.version.outputs.new_version }}
          git push origin main --tags

  deploy:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_PRIVATE_KEY }}
          script: |
            REPO_NAME="front-aws"
            VERSION="0.1.0"
            IMAGE="***/$REPO_NAME:$VERSION"

            echo "üîÑ Iniciando deploy da imagem: $IMAGE"

            # Start Docker
            sudo yum update -y || sudo apt update -y
            sudo systemctl start docker || sudo service docker start

            # Parar e remover container atual (mesmo que parado)
            CONTAINER_ID=$(docker ps -aq --filter "name=^${REPO_NAME}$")
            if [ -n "$CONTAINER_ID" ]; then
              echo "üõë Parando e removendo container existente $REPO_NAME..."
              docker rm -f "$CONTAINER_ID"
            else
              echo "‚ÑπÔ∏è Nenhum container atual encontrado com nome: $REPO_NAME"
            fi

            # Verificar se a porta 80 est√° ocupada por outro container
            PORT_80_CONTAINER=$(docker ps --format '{{.ID}} {{.Ports}}' | grep '0.0.0.0:80->' | awk '{print $1}')
            if [ -n "$PORT_80_CONTAINER" ]; then
              echo "‚ö†Ô∏è A porta 80 est√° sendo usada pelo container: $PORT_80_CONTAINER"
              echo "üõë Removendo container que est√° ocupando a porta 80..."
              docker rm -f "$PORT_80_CONTAINER"
            fi

            # Remover imagem antiga (ignorar erro se n√£o existir)
            echo "üßπ Removendo imagem local antiga..."
            docker rmi -f "$IMAGE" || echo "‚ÑπÔ∏è Imagem n√£o encontrada localmente."

            # Baixar imagem nova
            echo "‚¨áÔ∏è Baixando nova imagem..."
            docker pull $IMAGE

            # Subir container novo
            echo "üöÄ Subindo novo container..."
            docker run -d -p 80:80 --name $REPO_NAME $IMAGE
